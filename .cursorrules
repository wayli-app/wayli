# Cursor Agent Ground Rules for Wayli Project

Most important rules:
- Do not ever run `npx supabase db reset`.
- ABSOLUTELY DO NOT EVER RUN `npx supabase db reset`.
- Do not import $env/static/private into client-side code. This could leak sensitive information.
- When working on the web app, use the web/ folder as a base.
- Do not use the Supabase CLI to deploy functions. Assume we're running Supabase in a self-hosted manner.
- Prefix all log messages with an appropriate emoji.
- Always comply with a11y.
- Use Svelte v5's runes system where applicable.
- Strictly follow the Svelte v5 documentation. So also use 'onclick' instead of 'on:click', etc.

## Tech Stack & Project Context
- Frontend & Backend: SvelteKit
- Database: PostgreSQL (via Supabase)
- UI Styling: Tailwind CSS
- Deployment: Vercel
- Authentication: Supabase Auth
- This is a travel tracking and trip management application
- Implements background job processing with workers
- Follows TypeScript best practices

## Code Style & Standards
- Use TypeScript with strict typing
- Follow SvelteKit conventions and file structure
- Use Tailwind CSS classes for styling
- Prefer functional components over class-based
- Use async/await for all asynchronous operations
- Handle errors gracefully with try/catch blocks
- Prioritize readability and maintainability
- Use Zod for data validation
- Implement comprehensive error handling

## Architecture Guidelines
- Keep services modular and focused on single responsibilities
- Use dependency injection where appropriate
- Follow the existing service layer pattern
- Maintain separation between client and server code
- Use proper RLS (Row Level Security) policies in Supabase
- The webserver and workers are two separate processes

## Database & Supabase
- Always use RLS policies for data access
- Use the appropriate Supabase client (client/worker/server) for each context
- Follow the existing migration pattern
- Use proper indexing for performance
- Handle database errors appropriately

## Security
- Never expose sensitive environment variables to the client
- Always validate user input
- Use proper authentication checks
- Follow the principle of least privilege

## Testing
- Write tests for critical functionality
- Use descriptive test names
- Test both success and error scenarios
- Mock external dependencies appropriately

## Documentation
- Write clear comments and use JSDoc when appropriate
- Keep README.md and AI.MD updated
- Maintain CHANGELOG.md for significant changes
- Add JSDoc comments for complex functions
- Document API endpoints
- Comment complex business logic

## Performance
- Optimize database queries
- Use proper caching strategies
- Minimize bundle size
- Implement proper loading states
- Optimize for performance
- Use proper database indexing for queries
- Implement caching where appropriate
- Optimize bundle size with code splitting
- Use lazy loading for components and routes
- Monitor and optimize database query performance
- Implement proper error boundaries to prevent crashes

## Error Handling
- Provide meaningful error messages to users
- Log errors appropriately for debugging
- Use proper HTTP status codes
- Handle edge cases gracefully
- Use consistent error handling across the application
- Create custom error classes for different error types
- Log errors with appropriate context and severity
- Handle network errors gracefully

## File Organization
- Follow the existing project structure
- Group related files together
- Use consistent naming conventions
- Keep files focused and not too large
- Include full file path as a comment at the start of each file
- Update project structure in AI.MD when adding new files/directories
- Maintain up-to-date package.json

## Specific to This Project
- Use the existing job queue system for background tasks
- Follow the established export/import patterns
- Use the existing UI component library
- Maintain accessibility standards
- Support both light and dark themes

## Environment & Configuration
- Use the appropriate Supabase client for each context:
  - `client.ts` for browser/client-side code
  - `server.ts` for SvelteKit server-side code (API routes, load functions)
  - `worker.ts` for background workers and job processing
- Always use environment variables from the correct module:
  - `$env/static/public` for client-side public variables
  - `$env/static/private` for server-side private variables
  - `process.env` for Node.js/worker environments

## Background Job Processing
- Use the existing JobQueueService pattern for all background tasks
- Create job processors in `JobProcessorService` for new job types
- Always implement proper job cancellation checking
- Use progress tracking for long-running jobs
- Handle job failures gracefully with retry logic
- Use the worker-specific services for job processing

## API Design & Endpoints
- Follow RESTful conventions for API endpoints
- Use proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- Implement proper error handling and validation
- Use SvelteKit's `json()` helper for API responses
- Always validate user authentication in API routes
- Use proper TypeScript types for request/response data

## Database & Migrations
- Write migrations in `supabase/migrations/` with descriptive names
- Use proper RLS policies for all tables
- Include indexes for performance-critical queries
- Use PostGIS functions for geographic data
- Follow the existing schema patterns (timestamps, UUIDs, etc.)
- Always test migrations before deploying

## Component Architecture
- Use SvelteKit's component structure and conventions
- Follow the existing UI component patterns in `lib/components/ui/`
- Use Tailwind CSS for styling with consistent design tokens
- Implement proper loading states and error boundaries
- Use Svelte stores for state management
- Follow accessibility guidelines (ARIA labels, keyboard navigation)

## Testing Strategy
- Practice Test-Driven Development (TDD):
  - Write failing tests first
  - Implement minimum code to pass tests
  - Refactor while maintaining passing tests
- Use Vitest for unit and integration tests
- Aim for high test coverage (80% or higher)
- Write unit tests for services and utilities
- Test API endpoints with proper authentication
- Mock external dependencies (Supabase, external APIs)
- Test both success and error scenarios
- Use descriptive test names that explain the behavior
- Test accessibility features

## Performance & Optimization
- Use proper database indexing for queries
- Implement caching where appropriate
- Optimize bundle size with code splitting
- Use lazy loading for components and routes
- Monitor and optimize database query performance
- Implement proper error boundaries to prevent crashes

## Security Best Practices
- Always validate and sanitize user input
- Use proper authentication checks in all protected routes
- Implement rate limiting for API endpoints
- Use HTTPS in production
- Never expose sensitive data in client-side code
- Follow OWASP security guidelines
- Follow the principle of least privilege
- Always validate user input
- Use proper authentication checks

## Code Quality
- Use ESLint and Prettier for code formatting
- Write self-documenting code with clear variable names
- Add JSDoc comments for complex functions
- Keep functions small and focused
- Use TypeScript strict mode
- Avoid any types unless absolutely necessary
- Prioritize readability and maintainability
- Implement comprehensive error handling

## Deployment & DevOps
- Use environment-specific configurations
- Implement proper logging for debugging
- Use health checks for services
- Monitor application performance
- Implement proper backup strategies
- Use semantic versioning for releases

## Accessibility & UX
- Follow WCAG 2.1 AA guidelines
- Implement proper keyboard navigation
- Use semantic HTML elements
- Provide alternative text for images
- Ensure sufficient color contrast
- Test with screen readers
- Support both light and dark themes
- Implement dark mode compatibility
- Ensure mobile-friendly and responsive design
- Create modern and beautiful UI
- Consider accessibility in all design decisions

## Internationalization
- Use the existing i18n setup in `messages/`
- Support multiple languages (currently en/nl)
- Use proper date/time formatting for different locales
- Handle RTL languages if needed in the future
- Use proper number formatting for different regions

## Efficiency Algorithm
Follow this Algorithm for Efficiency:
1. Question every requirement critically
2. Delete unnecessary parts
3. Simplify and optimize remaining components
4. Accelerate cycle time
5. Automate as the final step

## Development Workflow
- Question and refine requirements
- Break down tasks into small, manageable issues
- For each task:
  a. Write failing tests
  b. Implement minimum code to pass tests
  c. Refactor and optimize
- Conduct self-review before suggesting merges
- Ensure CI passes before finalizing changes
- Look for opportunities to simplify and optimize code and workflows

## Truthfulness and Clarity
- Provide accurate, thoughtful answers
- Admit when you don't know something
- Be concise while ensuring clarity

## Windows Compatibility
- Provide PowerShell commands for Windows users
- Avoid Unix-specific commands (e.g., use `Remove-Item` instead of `rm`)
- Use cross-platform Node.js commands when possible

## Best Practices
- Follow RESTful API design principles when applicable
- Implement responsive design for components
- Regularly update dependencies and check for vulnerabilities
- Continuously apply the efficiency principles throughout development

Always refer to AI.MD for detailed project-specific guidelines and up-to-date practices.