# Claude Code Configuration for Wayli Project

## Most Important Rules
- Do not ever run `npx supabase db reset`
- ABSOLUTELY DO NOT EVER RUN `npx supabase db reset`
- Do not import $env/static/private into client-side code (could leak sensitive information)
- When working on the web app, use the web/ folder as a base
- Do not use the Supabase CLI to deploy functions (we're running Supabase self-hosted)
- Prefix all log messages with an appropriate emoji
- Always comply with a11y
- Use Svelte v5's runes system where applicable
- Strictly follow Svelte v5 documentation (use 'onclick' instead of 'on:click', etc.)

## Tech Stack & Project Context
- Frontend & Backend: SvelteKit
- Database: PostgreSQL (via Supabase)
- UI Styling: Tailwind CSS
- Deployment: Vercel
- Authentication: Supabase Auth
- This is a travel tracking and trip management application
- Implements background job processing with workers
- Follows TypeScript best practices

## Code Style & Standards
- Use TypeScript with strict typing
- Follow SvelteKit conventions and file structure
- Use Tailwind CSS classes for styling
- Prefer functional components over class-based
- Use async/await for all asynchronous operations
- Handle errors gracefully with try/catch blocks
- Prioritize readability and maintainability
- Use Zod for data validation
- Implement comprehensive error handling

## Architecture Guidelines
- Keep services modular and focused on single responsibilities
- Use dependency injection where appropriate
- Follow the existing service layer pattern
- Maintain separation between client and server code
- Use proper RLS (Row Level Security) policies in Supabase
- The webserver and workers are two separate processes

## Environment & Configuration
- Use the appropriate Supabase client for each context:
  - `client.ts` for browser/client-side code
  - `server.ts` for SvelteKit server-side code (API routes, load functions)
  - `worker.ts` for background workers and job processing
- Always use environment variables from the correct module:
  - `$env/static/public` for client-side public variables
  - `$env/static/private` for server-side private variables
  - `process.env` for Node.js/worker environments

## Background Job Processing
- Use the existing JobQueueService pattern for all background tasks
- Create job processors in `JobProcessorService` for new job types
- Always implement proper job cancellation checking
- Use progress tracking for long-running jobs
- Handle job failures gracefully with retry logic
- Use the worker-specific services for job processing

## API Design & Endpoints
- Follow RESTful conventions for API endpoints
- Use proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- Implement proper error handling and validation
- Use SvelteKit's `json()` helper for API responses
- Always validate user authentication in API routes
- Use proper TypeScript types for request/response data

## Database & Migrations
- Write migrations in `supabase/migrations/` with descriptive names
- Use proper RLS policies for all tables
- Include indexes for performance-critical queries
- Use PostGIS functions for geographic data
- Follow the existing schema patterns (timestamps, UUIDs, etc.)
- Always test migrations before deploying

## Component Architecture
- Use SvelteKit's component structure and conventions
- Follow the existing UI component patterns in `lib/components/ui/`
- Use Tailwind CSS for styling with consistent design tokens
- Implement proper loading states and error boundaries
- Use Svelte stores for state management
- Follow accessibility guidelines (ARIA labels, keyboard navigation)

## Testing Strategy
- Practice Test-Driven Development (TDD):
  - Write failing tests first
  - Implement minimum code to pass tests
  - Refactor while maintaining passing tests
- Use Vitest for unit and integration tests
- Aim for high test coverage (80% or higher)
- Test API endpoints with proper authentication
- Mock external dependencies (Supabase, external APIs)
- Test both success and error scenarios
- Use descriptive test names that explain the behavior
- Test accessibility features

## Security Best Practices
- Always validate and sanitize user input
- Use proper authentication checks in all protected routes
- Implement rate limiting for API endpoints
- Use HTTPS in production
- Never expose sensitive data in client-side code
- Follow OWASP security guidelines
- Follow the principle of least privilege

## Performance & Optimization
- Use proper database indexing for queries
- Implement caching where appropriate
- Optimize bundle size with code splitting
- Use lazy loading for components and routes
- Monitor and optimize database query performance
- Implement proper error boundaries to prevent crashes

## Accessibility & UX
- Follow WCAG 2.1 AA guidelines
- Implement proper keyboard navigation
- Use semantic HTML elements
- Provide alternative text for images
- Ensure sufficient color contrast
- Test with screen readers
- Support both light and dark themes
- Ensure mobile-friendly and responsive design
- Create modern and beautiful UI

## Internationalization
- Use the existing i18n setup in `messages/`
- Support multiple languages (currently en/nl)
- Use proper date/time formatting for different locales
- Handle RTL languages if needed in the future

## Efficiency Algorithm
Follow this Algorithm for Efficiency:
1. Question every requirement critically
2. Delete unnecessary parts
3. Simplify and optimize remaining components
4. Accelerate cycle time
5. Automate as the final step

## Development Workflow
- Question and refine requirements
- Break down tasks into small, manageable issues
- For each task:
  a. Write failing tests
  b. Implement minimum code to pass tests
  c. Refactor and optimize
- Conduct self-review before suggesting merges
- Ensure CI passes before finalizing changes
- Look for opportunities to simplify and optimize code and workflows

## Error Handling
- Provide meaningful error messages to users
- Log errors appropriately for debugging
- Use proper HTTP status codes
- Handle edge cases gracefully
- Use consistent error handling across the application
- Create custom error classes for different error types
- Log errors with appropriate context and severity
- Handle network errors gracefully

## Code Quality
- Use ESLint and Prettier for code formatting
- Write self-documenting code with clear variable names
- Add JSDoc comments for complex functions
- Keep functions small and focused
- Use TypeScript strict mode
- Avoid any types unless absolutely necessary

## Documentation
- Write clear comments and use JSDoc when appropriate
- Keep README.md and AI.MD updated
- Document API endpoints
- Comment complex business logic

## Cross-Platform Compatibility
- Provide PowerShell commands for Windows users when relevant
- Avoid Unix-specific commands when alternatives exist
- Use cross-platform Node.js commands when possible

## Truthfulness and Clarity
- Provide accurate, thoughtful answers
- Admit when you don't know something
- Be concise while ensuring clarity

Always refer to AI.MD for detailed project-specific guidelines and up-to-date practices.